## 0801
# 스프링부트

## JPA : Java Persistence API - 퍼시스턴스는 영속성 이다
	자바 영속성 API
	JAVA ORM API 표준
			ㄴ Object Relational Mapping
			객체와 관계형 데이터베이스 맵핑(연결한다)여기서 오브젝트는 자바오브젝트
			  ㄴ Java Object(Class) ==이것이 Entity클래스
			  
	Java Obejct(Entity class) <--> ORM <--> 관계형 데이터 베이스
	이것을 JPA에서 제공하는 어노테이션을 사용하면 자동으로 클래스에 적용된다 
	
	
### Entity
	엔티티는 DB테이블과 연결된 클래스
								Persistence Context영역
									
	Entity		Entity Manager --> Entity	Entity
	Manager	-->
	Factory		Entity Manager --> Entity	Entity
	
	Entity : database 의 table에 대응하는 class
			 @Entity 어노테이션을 붙임
			 
	Entity Manager Factory : Entity Manager Instance 를 생성, 관리 한다
							Application 을 실행하면 하나가 만들어진다
							Client 로 부터 request가 들어오면
							Entity Manager Factory 가 Entity Manager 를 생성한다
							
	Entity Manager : Persistence Context(영속성 컨텍스트) 에 접근해서
					Entity를 대상으로 database 작업(CRUD)을 처리한다
					
					Persistence Context (영속성 콘텍스트)
					
					1차 cache
					@Id Entity		item2 라는 Entity가 
	item12 를 얻고자	1L	item1		1차 cache 에 저장되지 않은 경우
	2L로 조회함		2L	item2		Database 에서 조회한다
	
	1차 cache 에서	item2라는 Entity를
	item2를 반환		DataBase에서 조회해서
					1차 cache에 저장한다
					
	1차 cache : item(Entity) 을 영속성 컨텍스트에 Map<Key,Value> 형태로 저장
				조회시에는 find() 메소드를 호출한다
				
		ㄴ동일한 transaction 에서 Key값이 같은 경우에는
		  동일한 Entity임을 보장해준다 <-- 동일성보장
		  
## database 초기화 DDL AUTO option

	spring.jpa.hibernate.ddl-auto=create
	
	create : 기존 table 삭제한 후, 새 table 생성
	none : 사용하지 않음
	create-drop : 기존 table 삭제한 후, 새 table 생성 / 종료할때 table 삭제
	update : 변경된 내용만 반영
	validate : Entity와 table이 정상적으로 Mapping 되었는지 확인한다
	
	
## 엔티티 작성예시

	//Entity 클래스 이름과 table이름을 다르게 하는경우
	//테이블 이름을 바꿔서 하고싶을경우
	//@Table(name="colleaugue")
	@Entity
	public class Student {
		
		@Id
		@GeneratedValue(strategy=GenerationType.IDENTITY)//오토인크리먼트
		private Long id;
		
		//컬럼이름을 바꾸고싶을때 nullable을 false로 할 시 notnull
		// length = 길이 제한
		@Column(name="name", nullable=false, length=30)
		private String myName;
		private int myHeight;
		//이렇게하면 db에서는 스네이크케이스로 생성된다
	}
	
## Enum 해당클래스의 스태틱상수들
### 예제
	public enum ItemStatus {
		//이넘은 itemStatus의 객체를 갖고있는 상수
		// ItemStatus SELL = new ItmStatus
		// ItemStatus SOLD_OUT = new ItmStatus 와 같은것
		SELL, SOLD_OUT
	}

## Query Method
	메소드는 이미 pom.xml에서 받았다
### 사용법
	Query Method 이름 형식]
		find(EntityClass 이름) By(멤버변수이름) -- find == select , By 컬럼명(단 자바로하니까 엔티티멤버변수이름)
	
	Query Method 를 호출하려면
	JpaRepository 인터페이스를 extends 하는 인터페이스를 작성해야한다
	--itemrepository 참조
	
### 예제
	public interface ItemRepository extends JpaRepository<Item,Long>{
		//find(Entity클래스 이름) By(멤버변수이름)
		//엔티티 클래스 이름은 제네릭으로 지정했기때문에 생략할수있다
		List<Item> findByItemNm(String ItemNm); // select * from item where itemNm
		//여기서 findByItemNm()메소드를 쿼리 메소드라고 한다
		
	}

## Junit테스트
	해당 메소드만 드래그하고 런애즈제이유닛하면 해당 메소드만 테스트를 실행한다
	@Transactional 이것은 테스트를하고 커밋을 하지않고 다시 롤백한다
### 예제
	@SpringBootTest
	//@Transactional
	//@Transactional 이것은 테스트를하고 커밋을 하지않고 다시 롤백한다
	class ItemRepositoryTest {
		
		@Autowired
		private ItemRepository itemRepository;
	
		
		public void createItemList() {
			for(int i = 1; i<=10; i++) {
				Item item = new Item();
				item.setItemNm("상품"+i);
				item.setPrice(10000+i*100);
				item.setItemDetail("상품상세설명"+i);
				item.setItemSellStatus(ItemSellStatus.SELL);
				item.setStockNumber(100);
				item.setRegTime(LocalDateTime.now());
				item.setUpdateTime(LocalDateTime.now());
				
				//save는 db에 insert한다는 의미
				Item savedItem = itemRepository.save(item);
			}
		}
		
		//DisplayName은 무슨테스트인지 출력해주는 어노테이션
		@Test
		@DisplayName("상품명조회테스트")
		public void findByItemNmtest() {
			createItemList();
			List<Item> itemList = itemRepository.findByItemNm("상품1");
			for(Item item : itemList) {
				System.out.println(item.toString());
			}
		}

## @Query 어노테이션 - JPQL
	ㄴ Query Method에 붙임
	JPQL(Java Persistence Query Language) --(특정 데이터베이스에 종속되지않고 범용적으로 사용하는 sql문)
	기본적으로 제공하는 find By ~~ 가 아닌 복잡한거 사용할때 JPQL을 사용한다
### 예제
	sql과 비슷하지만 테이블이름이 아닌 java 엔티티이름 을 불러온다
	참조변수를 하나 써줘야한다 여기서는 i가 참조변수
	:파라미터이름 은 파라미터로 받은값을 대입한다는 뜻
	Param으로 설정한 이름을 :안에 넣어도되고 Param을 따로 설정안해주면 원래 멤버필드명
	@Query("select i from Item i where i.itemDetail like %:itemDetail% order by i.price desc")
	List<Item> findByItemDetail(@Param("itemDetail") String itemDetail);
	
## Native Query
### 예제
	// Native Query
	@Query(value="select * from item i where i.item_detail like "
			+ "%:itemDetail% order by i.price desc",nativeQuery=true)
	List<Item> findByItemDetailNative(@Param("itemDetail") String itemDetail);
	
## QueryDSL
	JPQL 을 java code로 작성할 수 있도록 도와주는 API
	java code로 작성하기 때문에 compile 시 오류를 발견할 수 있음
	동적으로 query를 생성할 수 있음
	
	maven repository > querydsl-jpa / querydsl-apt 두개 디펜던시
	https://mvnrepository.com/artifact/com.querydsl/querydsl-jpa/5.0.0
	https://mvnrepository.com/artifact/com.querydsl/querydsl-apt/5.0.0
	
	아래 이것도 추가
	<!-- QueryDSL 에서 사용하는 q클래스 라는걸 만들어줌(내부적인 속도의 향상을 위해) -->
	<plugin>
		<groupId>com.mysema.maven</groupId>
		<artifactId>apt-maven-plugin</artifactId>
		<version>1.1.3</version>
		<executions>
			<execution>
				<goals>
					<goal>process</goal>
				</goals>
				<configuration>
					<outputDirectory>target/generated-sources/java</outputDirectory>
					<processor>com.querydsl.apt.jpa.JPAAnnotationProcessor</processor>
				</configuration>
			</execution>
		</executions>
	</plugin>
	
### 예제
	@Test
	@DisplayName("queryDSL 테스트")
	public void querydslTest() {
		createItemList();
		//entity query factory
		JPAQueryFactory jpaQueryFactory = new JPAQueryFactory(entityManager);
		//QItem qItem = new QItem("i");
		QItem qItem = QItem.item;//위와같은것
		//QItem qItem = item; 또는 임포트할때 static으로 임포트하면된다
		
		/*
		select * from item i where i.item_detail like
		%:itemDetail% order by i.price desc
		*/
		//메소드체인을할땐 이렇게 아래로 띄면서쓴다
		List<Item> selectedItem = 	jpaQueryFactory.select(qItem)
									.from(qItem)
									.where(qItem.itemSellStatus.eq(ItemSellStatus.SELL))
									.where(qItem.itemDetail.like("%3%"))
									.orderBy(qItem.price.desc())
									.fetch();
		//fetch()메소드를 써야 이 조건에 해당하는 문구들을 갖고온다
		System.out.println("---------------(query dsl)현재 판매중 상품 갖고오기 시작--------------");
		for(Item data : selectedItem) {
			log.info(data);
		}
		System.out.println("---------------(query dsl)현재 판매중 상품 갖고오기 종료--------------");
	}
	
--------------------------------

## 0802
### thymeleaf 타임리프
	자동완성 설치
	name : Thymeleaf
	URL : http://www.thymeleaf.org/eclipse-plugin-update-site/
	
### 타임리프 사용예제
	void는 매핑주소를 따라간다
	
	@GetMapping("/test/t1")
	public void t1(Person person, Model model) {
		
		person.setName("강아지");
		person.setHeight(188);
		
		model.addAttribute("text", "String Boot 2.7.14");
	}
	
	<p th:text="${text}">Spring Boot</p>
	<hr>
	<p th:text="${person}">person 객체</p>
	<p th:text="${person.name}">person 네임</p>
	<p th:text="${person.height}">person 키</p>
	
	이런식으로 사용가능
	
# 디펜던시 추가방법
	해당프로젝트 우측마우스 클릭
	Spring > Add Starters
	
### 타임리프 사용예제2
	<a th:href="@{/test/t5(name='강아지',height=184)}">name,height를 파라미터로 전달할때 /test/t5</a>
	스트링값으로 받아오기때문에
	
## dialect 추가 - 타임리프 레이아웃 
		<!-- https://mvnrepository.com/artifact/nz.net.ultraq.thymeleaf/thymeleaf-layout-dialect -->
		<dependency>
			<groupId>nz.net.ultraq.thymeleaf</groupId>
			<artifactId>thymeleaf-layout-dialect</artifactId>
		</dependency>
### 설명
	templates에 fragments라는 폴더와 layouts라는 폴더를 만든다
	layouts에는 layout.html을 만들고
	
	
## Spring Security 적용하기
	회원 가입이나 로그인 로그아웃에 적용
	회원 역할에 따라 권한을 달리하여 
	접근할 수 있는 페이지를 다르게 할 수 있다
	
	시큐리티 디펜던시를 넣으면
	Using generated security password: 3707acff-0374-44d1-aec8-efcd5b0f10b4
	이게 콘솔에 뜬다
	
	사이트에 들어가면 로그인창이 뜨는데
	아이디는 user 비밀번호는 3707acff-0374-44d1-aec8-efcd5b0f10b4 를입력하면 된다
	
### 세큐리티 아이디 비번 설정 application.properties
	# Spring Security user login 설정
	spring.security.user.name=user
	spring.security.user.password=1111
	
### 세큐리티 파일 설정 SecurityConfig.java
	@Configuration
	@EnableWebSecurity
	public class SecurityConfig {
		
		// @Bean : Spring Framework가 메모리에 미리 객체를 생성해놓음 - 서버 시작시
		
		@Bean
		public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
			//.loginPage(null) 로그인패턴
			//.defaultSuccessUrl(null) 로그인 성공시 나타낼 페이지
			//.usernameParameter("email") user라고 정해져있는걸 email로 바꾼것
			//.failureUrl("/members/login/error")로그인 실패시 이동할 url
			//and는 조건추가
			//.logoutRequestMatcher(new AntPathRequestMatcher("")) 로그아웃했을때 이동할 url패턴
			//.logoutSuccessUrl("/"); 로그아웃 성공시 이동할
			http.formLogin()
				.loginPage("/members/login")
				.defaultSuccessUrl("/")
				.usernameParameter("email")
				.failureUrl("/members/login/error")
				.and()
				.logout()
				.logoutRequestMatcher(new AntPathRequestMatcher("/member/logout"))
				.logoutSuccessUrl("/");
			return http.build();
		}
		
## 타임리프 예제3
	<form action="/members/new" role="form" method="post"
			th:object="${memberFormDto}">
			<div class="form-group">
				<label th:for="name">이름</label> <input type="text" th:field="*{name}"
					class="form-control" placeholder="이름을 입력해주세요">
				<p th:if="${#fields.hasErrors('name')}" th:errors="*{name}"
					class="fieldError">Incorrect data</p>
			</div>
			
	${}가 *{}로 바뀐것을 알 수 있다
	
			<input type="hidden" th:name="${_csrf.parameterName}"
			th:value="${_csrf.token}">
			
	이것은 스프링 시큐리티를 사용하기때문에 토큰값을 지정해준것
---
---
---

	
## 0804
### 로그인 로그아웃 기능 구현하기
	Spring Security에서 UserDetailsService 인터페이스를 implements 하는
	클래스를 작성해서 로그인 기능을 구현함
	
	UserDetailsService 인터페이스는 데이타베이스에서 회원정보를 가져오는 역할을 한다
	
		loadUserByUsername() 메소드를 overriding 해서
		회원정보를 조회하고 사용자의 정보와 권한을 갖는
		UserDetail 인터페이스를 반환한다
				ㄴ Spring Security에서 회원의 정보를 담는 기능을 한다
				  UserDetail 인터페이스를 임플먼츠 하는 클래스(User)를 작성한다
				  									ㄴ 클래스(User)의 객체를 생성함
		
## Optional 옵셔널


## 리터럴데이터
	자바의메모리영역은 열몇개가된다
	Method Area --클래스 정보가 올라가는곳
	call stack
	heap --new 로 생성하면 이 영역에 올라가게된다 new옆에오는 클래스는 다 생성자이다
	
	리터럴 데이터를 만들면 메소드에어리어에 영역을 만들어서(constant pool)
	
	new로 만든건 heap영역
	
	String a = "1"; 이렇게하면 메소드에어리어에 상수로 저장되고
	
	String b = new String("1"); 이렇게하면 Heap메모리에 저장된다
	
### 함수가 클래스 밖에 있으면 함수 그것이 클래스 안에 있으면 메소드

### 람다 짧게 설명
	람다식은 메소드를 변수처럼 활용하고싶어서 생긴것
	그렇기때문에 접근제한자,타입, 메소드 명을 생략해서 만들게 되는것이다
	
	() -> new String("테스트")
	
	
	Public String test1(){
		return new String("테스트");
	}
	
	함수형 인터페이스에 대해 공부하면 더 잘 알수있다
	
### 자바영역 짧게 설명
	자바의메모리영역은 열몇개가된다
	Method Area --데이터 정보가 올라가는곳
	call stack
	heap --new 로 생성하면 이 영역에 올라가게된다 new옆에오는 클래스는 다 생성자이다
	
	리터럴 데이터를 만들면 메소드에어리어에 영역을 만들어서(constant pool)
	
	new로 만든건 heap영역
	
	String a = "1"; 이렇게하면 메소드에어리어에 상수로 저장되고
	
	String b = new String("1"); 이렇게하면 Heap메모리에 저장된다
	
	a = "2"; 로 할 시 "1"은 사라지지않고 계속 메모리영역에 남아있으며
	(즉, 메모리주소는 계속 고정적이라 리터럴 데이터라고 한다)
	
	b = new String("2"); 로 할경우 new String("2") 를 쓰는 참조객체가 더이상없으면
	가비지 컬렉터에 의해 사라지게된다
	String c = new String("2"); 를하게되면 Heap영역에 새로운 2라는 데이터가 만들어지고
	그 주소를 갖다가 c가 쓰게되며
	b의 "2"와는 다른것이라 서로 주소가 다르게 되는것 
	
## thymeleaf-extras-pringsecurity5
	타임리프에서 시큐리티를 적용하는 의존성
	https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity5
	<!-- thymeleaf-extras-springsecurity5 -->
		<dependency>
			<groupId>org.thymeleaf.extras</groupId>
			<artifactId>thymeleaf-extras-springsecurity5</artifactId>
		</dependency>
		
## 연관 관계 맵핑
	맵핑된 Entity를 조회할 때 지연로딩 방식과 즉시 로딩 방식이 있다
	지연로딩 - 필요할때 로딩 : 대부분 많이 사용하는방식
	즉시로딩 - 미리 다 로딩 : 미리로딩하면 느려서 선호하지않음
	
	
### 연관관계 맵핑종류
	1) 1:1 <-- @OneToOne
	2) 1:N <-- @OneToMany
	3) N:1 <-- @ManyToOne
	4) N:N <-- @ManyToMany
	
### 연관관계 맵핑방향
	1) 단방향
	2) 양방향
		
### 즉시로딩 FetchType.EAGER
	@OneToOne(fetch=FetchType.EAGER)
	
	@OneToOne과 @ManyToOne 방식으로 매핑할때 기본값이다
	Entity를 조회할 때 해당 Entity와 Mapping 된 Entity를 한꺼번에 조회한다
	data를 조회할 때 연관된 모든 객체의 데이터를 모두 다 한꺼번에 조회한다
	(조회는 메모리에 올린다는 의미이다)
### 지연로딩 FetchType.LAZY
	@OneToMany(fetch=FetchType.LAZY)
	
	@OneToMany 방식으로 매핑할때 기본값이다
	필요한 시점에 연관된 객체(Entity)의 data를 불러온다
	
### N:1 Mapping설명
	장바구니에는 고객이 구매하고자 하는 상품들을 담을수 있다
	여러개의상품N 고객1
	
	하나의 장바구니에는 여러개의 상품을 담을 수 있다
	1:N
	
	하나의 상품은 여러 장바구니의 담겨질 수 있다
	1:N
	
	장바구니T - 장바구니상품T - 상품	
	
	
### orders테이블과order_item 테이블 관계 Mapping 하기
	orders 테이블의 orders_id 컬럼(의 값) 을 <--참조키(reference key)
	order_item 테이블의 orders_id 컬럼에서 사용하도록 설정
		ㄴ자식테이블			ㄴ 외래키(foreign key)
		
	어떤 상품을 주문한지 알 수 있고
	주문한 상품이 어떤 주문에 속해 있는지 파악할 수 있음
	
	*********************************************
	외래키로 양방향 조회를 할 수 있다
	*********************************************